- title: الفصل 9 - تنظيم وهيكلة المشروع 
  content_markdown: >
    حتى الآن، كانت جميع أمثلة التعليمات البرمجية الخاصة بنا عبارة عن ملف واحد. دعنا نناقش كيف يمكن تنظيم التعليمات البرمجية الخاص بنا ومشاركتها بشكل أفضل مع الآخرين!
- title: الوحدات (Modules)
  content_markdown: |
    كل برنامج أو مكتبة في رست (Rust) هي *صندوق (crate)*
    
    يتكون كل صندوق (crate) من تسلسل هرمي (hierarchy) من *الوحدات (modules)*.
    
     يحتوي كل صندوق (crate) على وحدة جذر (root module).
     
     يمكن للوحدة أن تحتوي على متغيرات عامة (global variables) أو دوال أو هياكل (structs) أو سمات (traits) أو حتى وحدات (modules) أخرى!
     
     في رست (Rust) لا يوجد 1 لـ 1 في خريطة الملفات الخاصة بالتسلسل الهرمي لشجرة الوحدة (module tree hierarchy). يجب أن نبني شجرة الوحدة (module tree) بشكل واضح يدويًا في التعليمات البرمجية الخاصة بنا.  
- title: كتابة برنامج (Writing a Program)
  content_markdown: |
    البرنامج (Program) يملك وحدة جذر (root module) في ملف يسمى بـ `main.rs`.
- title: كتابة مكتبة (Writing a Library)
  content_markdown: |
    المكتبة (library) تملك وحدة جذر (root module) في ملف يدعى بـ `lib.rs`.
- title: الإشارة إلى وحدات وصناديق أخرى (Referencing Other Modules and Crates)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
  content_markdown: >
    يمكن الإشارة إلى العناصر الموجودة في الوحدات الأخرى عن طريق المسار الكامل للوحدة كما يلي 
    
    
    ```rust
    
    std::f64::consts::* 
    
    ``` 


    والطريقة الأسهل هي استعمال الكلمة المفتاحية **use**. فهي تتيح لنا تحديد عناصر معينة من الوحدات والتي نرغب في استخدامها في التعليمات البرمجية الخاصة بنا ودون استخدام المسار الكامل. على سبيل المثال، 
    
    
    ```rust
    
    std::f64::consts::PI 
    
    ``` 
    

    هنا يسمح لي فقط باستخدام المعرف `PI` في دالتي الرئيسية.
    
    
    **std** هي الصندوق الخاص بـ **المكتبة القياسية (standard library)** لرست (Rust) والتي تحوي هياكل بيانات ودوال مساعدة في التفاعل مع نظام التشغيل الخاص بك.  



    يمكنك العثور على دليل الصناديق (crates) الذي أنشأه مجتمع رست (Rust) ويمكنك البحث فيه عبر الموقع [https://crates.io](https://crates.io/).

- title: الإشارة لعدة عناصر (Referencing Multiple Items)
  content_markdown: |
    يمكن الإشارة لعدة عناصر في مسار وحدة واحدة (single module path) على النحو التالي:


    ```rust
    use std::f64::consts::{PI,TAU}
    ```

    فيريس لا يأكل TAU، بل يأكل PI فقط.
- title: إنشاء وحدات (Creating Modules)
  content_markdown: |
    عندما نفكر في التعليمات البرمجية، فإننا عادة نتخيل تسلسلًا هرميًا (hierarchy) للملفات المنظمة في مجلدات أو أدلة. يتيح لك رست (Rust) إنشاء وحدات (modules) وثيقة الصلة ببنية ملفك.


     هناك طريقتان في رست (Rust) للتصريح عن وحدة (module). على سبيل المثال، يمكن تمثيل الوحدة `foo` على النحو التالي:
     
     * إما بملف اسمه `foo.rs`.
     * أو عن طريق دليل اسمه "foo" وبداخله ملف "mod.rs".

- title: التسلسل الهرمي للوحدة (Module Hierarchy)
  content_markdown: >
    يمكن أن تعتمد الوحدة (module) على وحدة أخرى. من أجل إنشاء علاقة بينها وبين وحدتها الفرعية (sub-module)، ولهذا يجب عليك أن تكتب في الوحدة الأصلية ما يلي:


    ```rust

    mod foo;

    ```


    التصريح المبين في الأعلى سوف يبحث عن ملف باسم `foo.rs` أو `foo/mod.rs` ثم سوف يدرج محتواه داخل وحدة تسمى `foo` ضمن ذلك النطاق. 

- title: الوحدة المضمنة (Inline Module)
  content_markdown: >
    يمكن تضمين الوحدة الفرعية (sub-module) مباشرةً ضمن التعليمات البرمجية للوحدة.    
    
    
    أحد الاستخدامات الشائعة جدًا للوحدات المضمنة (inline modules) هو إنشاء وحدة اختبارات (unit tests). نقوم بإنشاء وحدة مضمنة لا توجد إلا عند استخدام رست (Rust) للاختبار (testing)!
    


    ```

    // يقوم هذا الماكرو بإزالة هذه الوحدة المضمنة عند ما يكون رست

    // ليس في وضع إختبار

    #[cfg(test)]

    mod tests {
        // لاحظ أننا لا نستطيع الوصول على الفور إلى 
        // الوحدة الأب. يجب أن نكون صريحين.
        use super::*;

        ... tests go here ...
    }

    ```
- title: الإشارة إلى وحدة داخلية (Internal Module Referencing)
  content_markdown: >
    يحتوي رست (Rust) على العديد من الكلمات المفتاحية التي يمكنك استخدامها في مسار `use` الخاص بك للوصول بسرعة إلى الوحدة التي تريدها:
    
    
    * الصندوق (`crate`) - وحدة الجذر لصندوقك
    
    * علوي (`super`) - الوحدة الأب لوحدتك الحالية
    
    * الذات (`self`) - الوحدة الحالية

- title: التصدير (Exporting)
  content_markdown: >
    بشكل افتراضي، لا يمكن الوصول إلى أعضاء (members) *الوحدة (module)* من خارجها (ولا حتى من الوحدات الفرعية الخاصة بها!). ولنجعل أعضاء الوحدة يمكن الوصول إليهم نستخدم الكلمة الفتاحية `pub`.


    وكذلك، افتراضيا لا يمكن الوصول إلى أعضاء *الصندوق (crate)* خارجه. ولتجعل أعضاء الصندوق قابلين للوصول ضع عليهم `pub` في *الوحدة الجذرية (root module)* لصندوقك (`lib.rs` أو `main.rs`).

- title: كشف الهيكل (Structure Visibility)
  content_markdown: >
    تمامًا مثل الدوال، يمكن التصريح للهيكل (structures) ما تريد أن يكشف منه خارج الوحدة النمطية باستخدام الكلمة المفتاحية `pub`.

  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20SeaCreature%20struct%20will%20be%20usable%20outside%20of%20our%20module%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20let's%20keep%20our%20weapon%20private%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
- title: التمهيد (Prelude)
  content_markdown: |
    ربما تتساءل كيف يمكننا الوصول إلى `Vec` أو `Box` في كل مكان من دون `use` لاستيرادهما. هذا بسبب وحدة التمهيد `prelude` في المكتبة القياسية (standard library).
    
    اعلم أنه في مكتبة رست (Rust) القياسية، أي شيء يتم تصديره في `std::prelude::*` متاح تلقائيًا لكل جزء من رست (Rust). هذا هو الحال بالنسبة لـ `Vec` و`Box` وبالنسبة للآخرين أيضًا (Option، Copy،
     إلخ.).

- title: تمهيدك الخاص (Your Own Prelude)
  content_markdown: >
    بالنظر لتمهيد (prelude) المكتبة القياسية (standard library)، فمن الشائع أن يكون لمكتبتك (library) وحدة تمهيدية (prelude module) خاصة بها كنقطة بداية حيث يجب على المستخدمين استيراد جميع هياكل البيانات الأكثر شيوعًا لاستخدام مكتبتك (على سبيل المثال، استخدم `use my_library::prelude::*`) .
    
     هو لا يتم استخدامه تلقائيًا في البرامج/المكتبات التي تستخدم الصندوق الخاص بك، ولكنه تقليد جيد يجب اتباعه حتى يعرف الأشخاص من أين يبدأون.
     
     
     يقول فيريس (Ferris): "كن رستاسيًا (rustacean) جيدًا وساعد سلطعونا زميلًا لك للخروج بتمهيد جيد!"

- title: الفصل 9 - الخلاصة
  content_markdown: >
    لديك الآن بعض الحيل في جعبتك عندما يتعلق الأمر بإنشاء تطبيقات ومكتبات في رست(Rust) وتكون جاهزة للعالم. لا تقلق بشأن تذكر كل شيء. مع نمو مكتبتك واستخدامها من قبل أشخاص آخرين، ستجد ما هو الأفضل في كل مرحلة.


    المصادر:
    
      - [إرشادات لكتابة واجهة مبرمج التطبيقات (APIs) في رست (Rust)](https://rust-lang.github.io/api-guidelines/)
